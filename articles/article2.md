
---

# الدليل الشامل لفهم أحداث الحفظ والمعالجة في Django

## متى نستخدم save و signals و form_valid و clean؟

عند العمل باستخدام Django، يواجه المطوّر سؤالًا محوريًا يتكرر كثيرًا:

> **أين أضع المنطق البرمجي؟**

> هل أضعه في `model`؟  
> أم في `form`؟  
> أم في `view`؟  
> أم أستخدم `signals`؟

الإجابة الخاطئة تؤدي إلى:

- كود متشابك
- منطق مكرر
- صعوبة الصيانة
- أخطاء غير متوقعة

هذا المقال يقدّم **خريطة ذهنية واضحة** لفهم كل أداة، ودورها الحقيقي، ومتى تُستخدم بالضبط.

---

## أولًا: دورة حياة البيانات في Django

لفهم الأدوات، يجب فهم **تدفّق البيانات**:

1. المستخدم يُدخل بيانات (Form)
2. ا Django يتحقق من صحة البيانات (Validation)
3. البيانات تُعالج (Business Logic)
4. البيانات تُحفظ أو تُعدّل أو تُحذف
5. أنظمة أخرى قد تتفاعل مع هذا التغيير

كل مرحلة لها **مكانها الصحيح** في Django.

---

## ا QuerySet — كيف نتعامل مع البيانات؟

### ما هو QuerySet؟

هو تمثيل ذكي لاستعلام قاعدة البيانات، وليس البيانات نفسها.

```python
Book.objects.filter(is_active=True)
```

### متى نستخدمه؟

- جلب البيانات    
- التصفية
- الترتيب
- العد
- التحقق من الوجود
### لماذا هو مهم؟

لأنه:

- ا Lazy (لا ينفّذ فورًا)
- قابل للتركيب
- آمن
- محسّن للأداء

---

## ا Q Object — بناء شروط ذكية

### ما هو Q؟

أداة لبناء شروط معقدة باستخدام:

- OR
- AND
- NOT

```python
Q(author="Ali") | Q(year=2024)
```

### متى نستخدمه؟
- البحث المتقدم
- الشروط الديناميكية
- عندما لا يكفي filter العادي
---

## ا clean و clean_field — التحقق من صحة البيانات

### clean_field()
تتحقق من **حقل واحد فقط**

```python
def clean_email(self):
    ...
```

### clean()

تتحقق من **علاقة عدة حقول ببعضها**

```python
def clean(self):
    ...
```

### متى تُستخدم؟

- قبل أي حفظ
- عند `form.is_valid()`
- لمنع إدخال بيانات خاطئة

### ملاحظة مهمة
 لا تضع منطق تنفيذ هنا  
فقط تحقق Validation

---

## ا save() — منطق الكائن نفسه

### ما هي save()؟

دالة تُنفّذ عند حفظ الكائن في قاعدة البيانات.

```python
def save(self, *args, **kwargs):
    # منطق قبل الحفظ
    super().save(*args, **kwargs)
```

### متى نستخدمها؟

- عندما يكون المنطق **جزءًا من هوية الكائن**
- يجب أن يعمل في:
    - Admin
    - Forms
    - API
    - Shell

### أمثلة صحيحة:
- حساب قيمة تلقائيًا
- تعديل حقل قبل التخزين
- ضمان consistency

### متى لا نستخدمها؟

- عند الحاجة إلى request
- عند الحاجة إلى user
- عند منطق خاص بواجهة واحدة

---

## ا form_valid() — منطق مرتبط بالسياق

### ما هي؟

دالة في **Class-Based Views** تُنفّذ بعد نجاح التحقق من الفورم.

```python
def form_valid(self, form):
    obj = form.save(commit=False)
    obj.user = self.request.user
    obj.save()
    return super().form_valid(form)
```

### متى نستخدمها؟

- عند ربط البيانات بالمستخدم
- عند منطق يعتمد على request
- عند تخصيص سلوك واجهة معينة

### الفرق بينها وبين save()

- `save()` → منطق عام
- `form_valid()` → منطق سياقي
---

## ا  signals — التفاعل الجانبي

### ما هي signals؟
آلية تُنفّذ تلقائيًا عند حدوث حدث معين:

- post_save
- pre_save
- post_delete
- pre_delete

### متى نستخدمها؟

- عند تأثر كائنات أخرى
- عند إرسال إشعارات
- عند تسجيل Logs
- عند فصل المسؤوليات

### مثال ذهني:

> تم إنشاء مستخدم → أنشئ Profile تلقائيًا

### متى لا نستخدمها؟
- للمنطق الأساسي
- للعمليات الحرجة
- عندما يكون التتبع مهمًا

---

##  هل يوجد after_save؟

 لا يوجد شيء اسمه `after_save` في Django

البدائل الصحيحة:

- `post_save signal`
- أو منطق بعد `super().save()`

---

## الخريطة النهائية لاتخاذ القرار

| الحالة                 | الأداة الصحيحة |
| ---------------------- | -------------- |
| تحقق من البيانات       | clean          |
| منطق الكائن            | save           |
| منطق يعتمد على request | form_valid     |
| تفاعل جانبي            | signal         |
| شروط معقدة             | Q              |
| جلب البيانات           | QuerySet       |

---

## القاعدة الذهبية

> **اسأل دائمًا:** 
> هل هذا المنطق:
> - جزء من الكائن؟ 
> - مرتبط بالسياق؟
> - تفاعل جانبي؟

الإجابة تحدد الأداة مباشرة.

---

## الخلاصة

Django لا يفرض عليك أداة واحدة،  
لكنه يمنحك **نظامًا منضبطًا**:

- Model → الحقيقة
- Form → الصحة
- View → السياق
- Signal → التفاعل

استخدام كل أداة في مكانها الصحيح  
هو الفرق بين كود يعمل…  وكود احترافي.